todo:

pref_indexed_uwp_apps_enable
pref_hotkey_toggle_main_panel
pref_indexed_apps_show_sendto_shortcut

allow_drag_file
完整匹配
pref_indexed_folders
pref_check_version_update

skin
pref_night_mode


//case WM_TIMER:
//	if (wParam == 1001) {
//		KillTimer(hWnd, 1001);
//		ShowWindow(hWnd, SW_HIDE);
//	}
//	break;
//case WM_APP + 1:
//	ShowWindow(hWnd, SW_HIDE);
//	break;

	// 背景
if (lpDrawItem->itemState & ODS_SELECTED) {
	//FillRect(hdc, &rc, (HBRUSH)(COLOR_HIGHLIGHT + 1));
	//SetTextColor(hdc, GetSysColor(COLOR_HIGHLIGHTTEXT));

	COLORREF bgColor = RGB(30, 30, 60);
	HBRUSH hBrush = CreateSolidBrush(bgColor);
	FillRect(hdc, &rc, hBrush);
	DeleteObject(hBrush);

	SetTextColor(hdc, RGB(0, 0, 0));
}
else {
	//FillRect(hdc, &rc, (HBRUSH)(COLOR_WINDOW + 1));
	//SetTextColor(hdc, GetSysColor(COLOR_WINDOWTEXT));

	COLORREF bgColor = RGB(0, 0, 0);
	HBRUSH hBrush = CreateSolidBrush(bgColor);
	FillRect(hdc, &rc, hBrush);
	DeleteObject(hBrush);

	SetTextColor(hdc, RGB(0, 0, 0));
}

没有作用
// 填充背景（用 GDI+，避免混合问题）
//Color bgColor = (lpDrawItem->itemState & ODS_SELECTED) ? Color(255, 30, 30, 60) : Color(255, 0, 0, 0);
//SolidBrush bgBrush(bgColor);
//RectF bgRect((REAL)rc.left, (REAL)rc.top, (REAL)(rc.right - rc.left), (REAL)(rc.bottom - rc.top));
//graphics.FillRectangle(&bgBrush, bgRect);




	case WM_SIZE:
	{
		if (wParam == SIZE_MINIMIZED) {
			if (wParam == SIZE_RESTORED) {
				// 窗口从最小化恢复，但暂时不设置焦点
				//wasMinimized = false;
				SetFocus(hEdit);
			}
		}
	}
	break;
	//case WM_ACTIVATE:
	//{
	//	if (LOWORD(wParam) != WA_INACTIVE) {
	//		// 窗口变为活动状态，确保已经恢复后设置焦点
	//		SetFocus(hEdit);
	//	}
	//}
	break;



	//void ListViewManager::DrawItem(LPDRAWITEMSTRUCT lpDrawItem) {
//	int index = lpDrawItem->itemID;
//	if (index < 0 || index >= (int)filteredActions.size())
//		return;
//
//	std::shared_ptr<RunCommandAction> action = filteredActions[index];
//	HDC hdc = lpDrawItem->hDC;
//	RECT rc = lpDrawItem->rcItem;
//
//
//	// 背景
//	if (lpDrawItem->itemState & ODS_SELECTED) {
//		COLORREF bgColor =  RGB(30, 30, 60) ;
//		HBRUSH hBrush = CreateSolidBrush(bgColor);
//		FillRect(hdc, &rc, hBrush);
//		DeleteObject(hBrush);
//		SetTextColor(hdc, RGB(0, 0, 0));
//	}
//	else {
//		COLORREF bgColor =  RGB(0, 0, 0);
//		HBRUSH hBrush = CreateSolidBrush(bgColor);
//		FillRect(hdc, &rc, hBrush);
//		DeleteObject(hBrush);
//		SetTextColor(hdc, RGB(0, 0, 0));
//	}
//
//	SetBkMode(hdc, TRANSPARENT);
//	// 图标绘制（用系统图像列表）
//	if (hImageList && action->iImageIndex >= 0)
//		ImageList_Draw(hImageList, action->iImageIndex, hdc, rc.left + 4, rc.top + 4, ILD_TRANSPARENT);
//
//	RECT textRect = rc;
//	// 主标题
//	textRect.left += 60;
//	DrawText(hdc, action->GetTitle().c_str(), -1, &textRect, DT_LEFT | DT_TOP | DT_SINGLELINE | DT_NOPREFIX);
//	// 副标题
//	textRect.top += 16;
//	DrawText(hdc, action->GetTargetPath().c_str(), -1, &textRect, DT_LEFT | DT_SINGLELINE | DT_NOPREFIX);
//}






	void DrawItem2(LPDRAWITEMSTRUCT pDIS)
	{
		if (pDIS->itemID == -1)
			return;

		// 获取项文本
		wchar_t buffer[256];
		//ListView_GetItemText(hListView, pDIS->itemID, 0, buffer, 256);

		HDC hdc = pDIS->hDC;
		RECT rc = pDIS->rcItem;

		// 背景填充（选中项用暗色）
		COLORREF bgColor = (pDIS->itemState & ODS_SELECTED) ? RGB(30, 30, 60) : RGB(0, 0, 0);
		HBRUSH hBrush = CreateSolidBrush(bgColor);
		FillRect(hdc, &rc, hBrush);
		DeleteObject(hBrush);

		// 文本颜色
		SetTextColor(hdc, RGB(255, 255, 255));
		SetBkMode(hdc, TRANSPARENT);

		DrawText(hdc, buffer, -1, &rc, DT_LEFT | DT_VCENTER | DT_SINGLELINE);
	}


//ListView_SetBkColor(listViewManager.hListView, CLR_NONE);
//ListView_SetTextBkColor(listViewManager.hListView, CLR_NONE);

//InvalidateRect;


			// 返回空刷子以避免绘制默认白底
//static HBRUSH hBrush = CreateSolidBrush(RGB(0, 0, 0)); // 深色背景


测试显示json
// 转为 std::wstring，用于 MessageBoxW 显示
std::wstring wjson;
try {
	wjson = Utf8ToWString(utf8json);
}
catch (const std::exception& e) {
	std::wcerr << L"UTF-8 解析失败：" << Utf8ToWString(e.what()) << std::endl;
	return;
}

// ✅ 此时 wjson 是有效的 null-terminated std::wstring
MessageBoxW(NULL, wjson.c_str(), L"JSON 内容", MB_OK | MB_ICONINFORMATION);



	// 运行命令
	void Invoke() override
	{
		if (IsUwpItem)
		{
			ShellExecuteW(nullptr, L"open", targetFilePath.c_str(), nullptr, nullptr, SW_SHOWNORMAL);
		}
		else
		{
			ShellExecuteW(nullptr, L"open", targetFilePath.c_str(), arguments.empty() ? nullptr : arguments.c_str(),
						workingDirectory.c_str(), SW_SHOWNORMAL);
		}
	}

	// 打开所在文件夹
	void InvokeOpenFolder() const
	{
		const std::wstring folderPath = GetDirectory(targetFilePath);
		if (!folderPath.empty())
		{
			const std::wstring param = L"/select, " + targetFilePath;
			ShellExecuteW(nullptr, L"open", L"explorer.exe", param.c_str(), nullptr, SW_SHOWNORMAL);
		}
	}

	// 打开目标（快捷方式）指向文件夹
	void InvokeOpenGoalFolder() const
	{
		if (GetExtension(targetFilePath) == L".lnk")
		{
			const std::wstring resolvedPath = GetShortcutTarget(targetFilePath);
			if (!resolvedPath.empty())
			{
				const std::wstring param = L"/select, " + resolvedPath;
				ShellExecuteW(nullptr, L"open", L"explorer.exe", param.c_str(), nullptr, SW_SHOWNORMAL);
				return;
			}
		}
		InvokeOpenFolder();
	}

// 不好用，会残留一个 cmd进程
		std::wstring cmdLine = L"cmd.exe /c \"" + targetFilePath + L"\" & exit";


	void Invoke() override
	{
		// std::wstring cmdLine = L"explorer.exe \"" + targetFilePath + L"\"";
		std::wstring cmdLine = L"cmd.exe /c \"" + targetFilePath + L"\" & exit";

		STARTUPINFOW si = { sizeof(si) };
		PROCESS_INFORMATION pi = {};
		si.wShowWindow = SW_HIDE; // 隐藏控制台窗口

		BOOL success = CreateProcessW(
			nullptr,
			&cmdLine[0],
			nullptr,
			nullptr,
			FALSE,
			0,
			nullptr,
			workingDirectory.empty() ? nullptr : workingDirectory.c_str(),
			&si,
			&pi
		);

		if (success)
		{
			CloseHandle(pi.hProcess);
			CloseHandle(pi.hThread);
		}
		else
		{
		std::wstring errorMessage = L"启动失败，请检查路径或权限。" + targetFilePath;
			MainTools::ShowErrorMsgBox(errorMessage);
		}
	}

	void InvokeOpenFolder() const
	{
		const std::wstring folderPath = GetDirectory(targetFilePath);
		if (!folderPath.empty())
		{
			std::wstring param = L"/select,\"" + targetFilePath + L"\"";
			std::wstring cmdLine = L"explorer.exe " + param;

			STARTUPINFOW si = { sizeof(si) };
			PROCESS_INFORMATION pi = {};

			if (CreateProcessW(nullptr, &cmdLine[0], nullptr, nullptr, FALSE, 0, nullptr, nullptr, &si, &pi))
			{
				CloseHandle(pi.hProcess);
				CloseHandle(pi.hThread);
			}
		}
	}

	void InvokeOpenGoalFolder() const
	{
		std::wstring resolvedPath = targetFilePath;

		if (GetExtension(targetFilePath) == L".lnk")
		{
			resolvedPath = GetShortcutTarget(targetFilePath);
			if (resolvedPath.empty())
			{
				InvokeOpenFolder(); // fallback
				return;
			}
		}

		std::wstring param = L"/select,\"" + resolvedPath + L"\"";
		std::wstring cmdLine = L"explorer.exe " + param;

		STARTUPINFOW si = { sizeof(si) };
		PROCESS_INFORMATION pi = {};

		if (CreateProcessW(nullptr, &cmdLine[0], nullptr, nullptr, FALSE, 0, nullptr, nullptr, &si, &pi))
		{
			CloseHandle(pi.hProcess);
			CloseHandle(pi.hThread);
		}
	}


		// wprintf(L"当前索引: %d\n"+justName,0);
		// std::wcout  << justName << std::endl;

		//std::wcout << RunCommand << std::endl;
		//std::wcout << justName << std::endl;

		//OutputDebugStringW(justName.c_str());
		//OutputDebugStringW(RunCommand.c_str());
		//wstring temp = justName + L"\n" + RunCommand;
		//MessageBoxW(NULL, temp.c_str(), L"内容", MB_OK | MB_ICONERROR);




	// 处理 Ctrl+Backspace
	//static void HandleCtrlBackspace(HWND hwnd) {
	//    DWORD start = 0, end = 0;
	//    SendMessage(hwnd, EM_GETSEL, (WPARAM)&start, (LPARAM)&end);
	//    if (start > 0) {
	//        wchar_t text[1024] = { 0 };
	//        GetWindowText(hwnd, text, 1024);

	//        int i = (int)start - 1;
	//        while (i > 0 && text[i] == L' ') i--;       // 跳过空格
	//        while (i > 0 && text[i - 1] != L' ') i--;    // 找到单词边界

	//        SendMessage(hwnd, EM_SETSEL, i, start);
	//        SendMessage(hwnd, EM_REPLACESEL, TRUE, (LPARAM)L"");
	//    }
	//}


// 主进程函数
int APIENTRY wWinMain(_In_ HINSTANCE hInstance,
					_In_opt_ HINSTANCE hPrevInstance,
					_In_ LPWSTR lpCmdLine,
					_In_ int nCmdShow)
{
	// 初始化 Windows 通用控件库中指定的控件类型
	// INITCOMMONCONTROLSEX icex;
	// icex.dwSize = sizeof(INITCOMMONCONTROLSEX);
	// icex.dwICC = ICC_WIN95_CLASSES | ICC_STANDARD_CLASSES | ICC_BAR_CLASSES;  // 可根据需要添加更多
	// InitCommonControlsEx(&icex);


	//wcex.hbrBackground = (HBRUSH)(COLOR_WINDOW + 1);
	// wcex.hbrBackground = nullptr;



	// case WM_PAINT:
	// {
	// 	PAINTSTRUCT ps;
	// 	HDC hdc = BeginPaint(hWnd, &ps);
	//
	// 	HDC hdcMem = CreateCompatibleDC(hdc);
	// 	HBITMAP hbmMem = CreateCompatibleBitmap(hdc, ps.rcPaint.right - ps.rcPaint.left, ps.rcPaint.bottom - ps.rcPaint.top);
	// 	HBITMAP hbmOld = (HBITMAP)SelectObject(hdcMem, hbmMem);
	//
	// 	// 先在内存 DC 中绘制
	// 	HBRUSH hBrush = CreateSolidBrush(COLOR_UI_BG);
	// 	FillRect(hdcMem, &ps.rcPaint, hBrush);
	// 	DeleteObject(hBrush);
	//
	// 	// 在内存 DC 上绘制其他内容...
	//
	// 	// 再一次性拷贝到屏幕
	// 	BitBlt(hdc, ps.rcPaint.left, ps.rcPaint.top,
	// 		ps.rcPaint.right - ps.rcPaint.left,
	// 		ps.rcPaint.bottom - ps.rcPaint.top,
	// 		hdcMem, 0, 0, SRCCOPY);
	//
	// 	// 清理资源
	// 	SelectObject(hdcMem, hbmOld);
	// 	DeleteObject(hbmMem);
	// 	DeleteDC(hdcMem);
	//
	// 	EndPaint(hWnd, &ps);
	// }
	// return 0;



				// wchar_t buffer[256];
				// GetWindowText(hEdit, buffer, 256);
				// int len = GetWindowTextLengthW(hEdit);
				// std::wstring buffer(len, L'\0');
				// if (buffer.capacity() < 100)
				// 	buffer.reserve(100); // 只扩容一次，避免多次 resize 时内存重新分配
				// GetWindowTextW(hEdit, &buffer[0], 100);
				// buffer.resize(wcsnlen(buffer.c_str(), 100)); // 去除尾部空字符

				// buffer.reserve(100);             // 确保容量
				// buffer.resize(100);              // size=100，但不保证内容——我们马上就要覆盖
				if (buffer.size() < 100)

				// buffer.resize(wcsnlen(buffer.c_str(), 100));


	// HRSRC hRes = FindResource(hModule, MAKEINTRESOURCEW(IDR_SETTINGS_JSON), RT_RCDATA);
	//HRSRC hRes = FindResourceW(hModule, MAKEINTRESOURCEW(IDR_SETTINGS_JSON), L"RCDATA");
	//HRSRC hRes = FindResource(hModule, MAKEINTRESOURCE(IDR_SETTINGS_JSON), RT_RCDATA);
	//HRSRC hRes = FindResourceW(hModule, MAKEINTRESOURCEW(IDR_SETTINGS_JSON), L"RCDATA");





//static void ShowErrorMsgBox(const std::string& msg)
//{
//	const DWORD err = GetLastError();
//	char buf[256];
//
//	std::snprintf(buf, sizeof(buf), "%s，错误代码：%lu", msg.c_str(), err);
//	MessageBoxA(nullptr, buf, "错误", MB_OK | MB_ICONERROR);
//}



# -------------------- 修正部分开始 --------------------

# 1. 定义生成的资源文件的路径
set(RESOURCE_FILE ${CMAKE_CURRENT_BINARY_DIR}/windowsproject1.res)

# 2. 添加自定义命令来编译资源
#    这个命令会在 .rc 或 .json 文件变更时执行
add_custom_command(
        OUTPUT ${RESOURCE_FILE}
        COMMAND windres -i ${CMAKE_SOURCE_DIR}/windowsproject1.rc -o ${RESOURCE_FILE} -O coff
        # 明确指出此命令依赖于 .rc 文件和 .json 文件
        DEPENDS
        ${CMAKE_SOURCE_DIR}/windowsproject1.rc
        ${CMAKE_SOURCE_DIR}/settings.json
        COMMENT "Compiling resources with updated settings.json"
)

# 3. 将生成的 .res 文件作为目标的一个源文件
#    这是最关键的一步，它将自定义命令与你的可执行文件目标直接关联起来。
#    当 RESOURCE_FILE 过期时，CMake会先运行上面的自定义命令，然后再链接 WindowsProject1。
target_sources(WindowsProject1 PRIVATE ${RESOURCE_FILE})

# 移除下面的 add_custom_target 和 add_dependencies，它们是多余的。
# add_custom_target(resource_target ALL DEPENDS ${RESOURCE_FILE})
# add_dependencies(WindowsProject1 resource_target)

# -------------------- 修正部分结束 --------------------


#set(RESOURCE_FILE ${CMAKE_CURRENT_BINARY_DIR}/windowsproject1.res)
#
#add_custom_command(
#        OUTPUT ${RESOURCE_FILE}
#        COMMAND windres -i ${CMAKE_SOURCE_DIR}/windowsproject1.rc -o ${RESOURCE_FILE} -O coff
#        DEPENDS ${CMAKE_SOURCE_DIR}/windowsproject1.rc ${CMAKE_SOURCE_DIR}/settings.json
#        COMMENT "Recompiling resources including settings.json"
#)
#
#add_custom_target(resource_target ALL DEPENDS ${RESOURCE_FILE})
#add_dependencies(WindowsProject1 resource_target)
#target_sources(WindowsProject1 PRIVATE ${RESOURCE_FILE})


			// for (const auto& sub : settings2)
			// 	tabSet.insert(utf8_to_wide(sub.subPage));
			
			
			
			// subPages.assign(tabSet.begin(), tabSet.end());


static int GetLabelHeight2(HWND hwnd, std::wstring text, int labelWidth)
{
	RECT rc = {0, 0, labelWidth, 0}; // labelWidth 是你预设的宽度，例如 180 或 300
	// HFONT hFont = (HFONT)GetStockObject(hFontDefault);

	HDC hdc = GetDC(hwnd);
	SelectObject(hdc, hFontDefault);

	DrawTextW(hdc, text.c_str(), -1, &rc, DT_WORDBREAK | DT_CALCRECT);
	int labelHeight = rc.bottom - rc.top;
	ReleaseDC(hwnd, hdc);
	return labelHeight;
}


static int GetLabelHeight3(HWND hwnd, std::wstring text, int labelWidth)
{
	RECT rc = {0, 0, labelWidth, 0};

	HDC hdc = GetDC(hwnd);
	HFONT hOldFont = (HFONT)SelectObject(hdc, hFontDefault);

	// 计算文本绘制所需区域
	DrawTextW(hdc, text.c_str(), -1, &rc, DT_WORDBREAK | DT_CALCRECT);

	int labelHeight = rc.bottom - rc.top;

	// 可选：使用 TextMetrics 校验
	TEXTMETRIC tm;
	GetTextMetrics(hdc, &tm);
	int lineHeight = tm.tmHeight + tm.tmExternalLeading;

	SelectObject(hdc, hOldFont);
	ReleaseDC(hwnd, hdc);
	return labelHeight;
}

static int GetLabelHeight4(HWND hWnd, std::wstring text, int labelWidth)
{
	// PAINTSTRUCT ps;
	// HDC hdc = BeginPaint(hWnd, &ps);
	HDC hdc = GetDC(hWnd);

	// 获取客户区大小
	RECT clientRect;
	GetClientRect(hWnd, &clientRect);

	// 设置一个最大宽度为200的矩形
	RECT drawRect = {0, 0, labelWidth, clientRect.bottom};

	// 文本内容
	// LPCWSTR text = L"我是来自非洲的姑娘。心中向往神秘的东方,背起行囊寻找梦想,那是龙的故乡这里的人纯朴善良,淡淡微笑挂脸庞";

	// 复制 drawRect 以便计算文本高度
	RECT calcRect = drawRect;

	// 计算文本所需高度
	DrawTextW(hdc, text.c_str(), -1, &calcRect, DT_CENTER | DT_WORDBREAK | DT_CALCRECT | DT_EDITCONTROL);
	int textHeight = calcRect.bottom - calcRect.top;

	// 垂直居中：重新设置 drawRect 的 top 和 bottom
	int verticalOffset = (clientRect.bottom - textHeight) / 2;
	drawRect.top = verticalOffset;
	drawRect.bottom = verticalOffset + textHeight;

	// 设置背景透明（可选）
	SetBkMode(hdc, TRANSPARENT);

	// 实际绘制文本
	DrawTextW(hdc, text.c_str(), -1, &drawRect, DT_CENTER | DT_WORDBREAK | DT_EDITCONTROL);

	// EndPaint(hWnd, &ps);

	return drawRect.bottom - drawRect.top + 10;
}


				// HWND hContainer = CreateWindowExW(0, L"STATIC", nullptr,
				// 								WS_CHILD | WS_VISIBLE,
				// 								100, 0, 600, 380, hwnd, nullptr, nullptr, nullptr);



// 设置滚动范围xxuxu
static void UpdateScrollRange2(HWND hwnd, int contentHeight)
{
	const int viewHeight = 380; // 容器高度
	int maxScroll = MyMax(0, contentHeight - viewHeight);
	SetScrollRange(hwnd, SB_VERT, 0, maxScroll, TRUE);
	SetScrollPos(hwnd, SB_VERT, 0, TRUE);
}



		// SetBkMode(hdcStatic, OPAQUE);
		// SetBkColor(hdcStatic, COLOR_UI_BG);




// CLEARTYPE_QUALITY, VARIABLE_PITCH, L"微软雅黑");




	// HWND hWnd = CreateWindowW(L"SettingsWndClass", L"设置",
	// 	WS_OVERLAPPED | WS_CAPTION | WS_SYSMENU,
	// 	CW_USEDEFAULT, CW_USEDEFAULT, 480, 350,
	// 	hParent, nullptr, hInstance, nullptr);

	//HWND hWnd = CreateWindowW(L"SettingsWndClass", L"设置",
	//	WS_POPUP | WS_CAPTION | WS_SYSMENU | WS_MINIMIZEBOX | WS_EX_ACCEPTFILES,
	//	 //WS_POPUP | WS_VISIBLE,
	//	CW_USEDEFAULT, CW_USEDEFAULT, 480, 350,
	//	hParent, nullptr, hInstance, nullptr);


	case WM_CLOSE:
		DestroyWindow(hwnd);
		break;
	case WM_DESTROY:
		PostQuitMessage(0);
		break;



// Subclass procedure to handle hotkey input on an EDIT control
static LRESULT CALLBACK HotkeySubclassProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam, UINT_PTR uIdSubclass,
											DWORD_PTR dwRefData)
{
	switch (uMsg)
	{
	case WM_KEYDOWN:
	case WM_SYSKEYDOWN:
		{
			std::wstring hotkeyString;
			// 1. Check for modifier keys
			if (GetKeyState(VK_CONTROL) & 0x8000) hotkeyString += L"Ctrl + ";
			if (GetKeyState(VK_SHIFT) & 0x8000) hotkeyString += L"Shift + ";
			if (GetKeyState(VK_MENU) & 0x8000) hotkeyString += L"Alt + ";

			UINT vkCode = static_cast<UINT>(wParam);
			std::wstring keyStr;

			// 2. Ignore presses of modifier keys by themselves
			if (vkCode == VK_CONTROL || vkCode == VK_SHIFT || vkCode == VK_MENU || vkCode == VK_LWIN || vkCode == VK_RWIN)
			{
				SetWindowTextW(hWnd, hotkeyString.c_str()); // Show only modifiers so far
			}
			else
			{
				// std::wstring keyName = VKCodeToString(vkCode);
				// std::wstring keyName ;
				// if (!keyName.empty()) {
				//     hotkeyString += keyName;
				// }

				wchar_t keyName[64] = {};
				UINT scanCode = MapVirtualKey(vkCode, MAPVK_VK_TO_VSC) << 16;
				GetKeyNameTextW(scanCode, keyName, 64);
				hotkeyString += keyName;

				SetWindowTextW(hWnd, hotkeyString.c_str());
			}
			// 3. We handled this message; prevent default processing
			return 0;
		}

	// Clear the box on Backspace or Delete for user convenience
	case WM_KEYUP:
		{
			if (wParam == VK_BACK || wParam == VK_DELETE)
			{
				SetWindowTextW(hWnd, L"");
			}
			break;
		}

	case WM_KILLFOCUS:
		{
			// 如果用户仅按下修饰符单击，请清除框。
			wchar_t buffer[128];
			GetWindowTextW(hWnd, buffer, 128);
			std::wstring currentText = buffer;
			if (currentText == L"Ctrl + " || currentText == L"Shift + " || currentText == L"Alt + " ||
				currentText == L"Ctrl + Shift + " || currentText == L"Ctrl + Alt + " || currentText == L"Shift + Alt + "
				||
				currentText == L"Ctrl + Shift + Alt + ")
			{
				SetWindowTextW(hWnd, L"");
			}
			break;
		}
	}
	// For all other messages, use the default procedure
	return DefSubclassProc(hWnd, uMsg, wParam, lParam);
}


	if (!RegisterHotKey(s_mainHwnd, HOTKEY_ID_TOGGLE_MAIN_PANEL, MOD_ALT, 0x4B))
	{
		const DWORD error = GetLastError();
		if (error == ERROR_HOTKEY_ALREADY_REGISTERED)
		{
			MessageBox(nullptr, L"热键 Alt+K 已被占用", L"错误", MB_OK | MB_ICONERROR);
		}
		else
		{
			std::wstringstream ss;
			ss << L"热键注册失败，错误代码：" << error;
			MessageBox(nullptr, ss.str().c_str(), L"错误", MB_OK | MB_ICONERROR);
		}
	}

				// if (GetKeyState(VK_MENU) < 0) currentModifiers |= MOD_ALT_KEY;
				// if (GetKeyState(VK_CONTROL) < 0) currentModifiers |= MOD_CTRL_KEY;
				// if (GetKeyState(VK_SHIFT) < 0) currentModifiers |= MOD_SHIFT_KEY;
				// if (GetKeyState(VK_LWIN) < 0 || GetKeyState(VK_RWIN) < 0) currentModifiers |= MOD_WIN_KEY;





	// 假设 words 是用户输入的一个字符串，而不是分割后的单词列表
	// const int score_threshold = 75; // 相似度阈值 (0-100)
	const int score_threshold = 40; // 相似度阈值 (0-100)

	for (const auto& action : allActions)
	{
		const std::wstring& runCommand = action->RunCommand;

		// 使用 token_sort_ratio 可以忽略单词顺序，更灵活
		// 如果你还想匹配部分内容，可以用 partial_ratio
		double score = rapidfuzz::fuzz::token_sort_ratio(runCommand, keyword);

		if (score >= score_threshold)
		{
			const std::wstring& title = action->GetTitle();
			const std::wstring& subtitle = action->GetSubtitle();

					LVITEM item = {};
					item.mask = LVIF_TEXT | LVIF_IMAGE;
					item.iItem = ListView_GetItemCount(hListView);
					item.pszText = const_cast<LPWSTR>(title.c_str());
					item.iImage = (action->iImageIndex == -1) ? 0 : action->iImageIndex;
			
					ListView_InsertItem(hListView, &item);
					ListView_SetItemText(hListView, item.iItem, 1, const_cast<LPWSTR>(subtitle.c_str()));

			filteredActions.push_back(action);
			matchedCount++;
			if (matchedCount >= 7)
				break;
		}
	}


		{
			"key":"pref_exact_match",
			"title":"完整匹配",
			"type":"bool",
			"subPage":"feature",
			"defValue":false
		},
