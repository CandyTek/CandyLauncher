todo:

左侧栏提高一些，然后铺满，项目使用图标，左对齐

索引查看器:
快捷方式修复器，添加，一键检查某些快捷方式是否失效，以及使用everything来找回文件的位置，并可以编辑快捷方式


主面板：
把listview edit 主窗口的编辑框按键监听统一



当不使用透明图片背景时，使用传统的gdi 来渲染窗口内容
pref_night_mode
skin


设置项，包括已在注册表中注册的应用
设置项，在 %PATH% 上的任何位置包含exe bat lnkw
设置项，使用everything 来建立索引



后期：
小细节，编辑框 paint重绘，再次显示界面时 选中词语背景有点问题
小细节，统一窗口，列表，编辑框的一些共同按键事件
完善预设runner.json 也在桌面找应用
暴力测试各种设置项
添加，语言国际化
allow_drag_file


自动检查更新，不在提示
pref_check_version_update

索引查看器:
添加查看排除了哪些项



#简单的扩展：
#执行命令：cmd  打开一个新控制台，在里面输入命令
#计算： cal 使用一个科学计算库，来计算算式，保存历史记录，


//完整匹配
//解决更改主题后，列表内容显示不全
//case WM_TIMER:
//	if (wParam == 1001) {
//		KillTimer(hWnd, 1001);
//		ShowWindow(hWnd, SW_HIDE);
//	}
//	break;
//case WM_APP + 1:
//	ShowWindow(hWnd, SW_HIDE);
//	break;

	// 背景
if (lpDrawItem->itemState & ODS_SELECTED) {
	//FillRect(hdc, &rc, (HBRUSH)(COLOR_HIGHLIGHT + 1));
	//SetTextColor(hdc, GetSysColor(COLOR_HIGHLIGHTTEXT));

	COLORREF bgColor = RGB(30, 30, 60);
	HBRUSH hBrush = CreateSolidBrush(bgColor);
	FillRect(hdc, &rc, hBrush);
	DeleteObject(hBrush);

	SetTextColor(hdc, RGB(0, 0, 0));
}
else {
	//FillRect(hdc, &rc, (HBRUSH)(COLOR_WINDOW + 1));
	//SetTextColor(hdc, GetSysColor(COLOR_WINDOWTEXT));

	COLORREF bgColor = RGB(0, 0, 0);
	HBRUSH hBrush = CreateSolidBrush(bgColor);
	FillRect(hdc, &rc, hBrush);
	DeleteObject(hBrush);

	SetTextColor(hdc, RGB(0, 0, 0));
}

没有作用
// 填充背景（用 GDI+，避免混合问题）
//Color bgColor = (lpDrawItem->itemState & ODS_SELECTED) ? Color(255, 30, 30, 60) : Color(255, 0, 0, 0);
//SolidBrush bgBrush(bgColor);
//RectF bgRect((REAL)rc.left, (REAL)rc.top, (REAL)(rc.right - rc.left), (REAL)(rc.bottom - rc.top));
//graphics.FillRectangle(&bgBrush, bgRect);




	case WM_SIZE:
	{
		if (wParam == SIZE_MINIMIZED) {
			if (wParam == SIZE_RESTORED) {
				// 窗口从最小化恢复，但暂时不设置焦点
				//wasMinimized = false;
				SetFocus(hEdit);
			}
		}
	}
	break;
	//case WM_ACTIVATE:
	//{
	//	if (LOWORD(wParam) != WA_INACTIVE) {
	//		// 窗口变为活动状态，确保已经恢复后设置焦点
	//		SetFocus(hEdit);
	//	}
	//}
	break;



	//void ListViewManager::DrawItem(LPDRAWITEMSTRUCT lpDrawItem) {
//	int index = lpDrawItem->itemID;
//	if (index < 0 || index >= (int)filteredActions.size())
//		return;
//
//	std::shared_ptr<RunCommandAction> action = filteredActions[index];
//	HDC hdc = lpDrawItem->hDC;
//	RECT rc = lpDrawItem->rcItem;
//
//
//	// 背景
//	if (lpDrawItem->itemState & ODS_SELECTED) {
//		COLORREF bgColor =  RGB(30, 30, 60) ;
//		HBRUSH hBrush = CreateSolidBrush(bgColor);
//		FillRect(hdc, &rc, hBrush);
//		DeleteObject(hBrush);
//		SetTextColor(hdc, RGB(0, 0, 0));
//	}
//	else {
//		COLORREF bgColor =  RGB(0, 0, 0);
//		HBRUSH hBrush = CreateSolidBrush(bgColor);
//		FillRect(hdc, &rc, hBrush);
//		DeleteObject(hBrush);
//		SetTextColor(hdc, RGB(0, 0, 0));
//	}
//
//	SetBkMode(hdc, TRANSPARENT);
//	// 图标绘制（用系统图像列表）
//	if (hImageList && action->iImageIndex >= 0)
//		ImageList_Draw(hImageList, action->iImageIndex, hdc, rc.left + 4, rc.top + 4, ILD_TRANSPARENT);
//
//	RECT textRect = rc;
//	// 主标题
//	textRect.left += 60;
//	DrawText(hdc, action->GetTitle().c_str(), -1, &textRect, DT_LEFT | DT_TOP | DT_SINGLELINE | DT_NOPREFIX);
//	// 副标题
//	textRect.top += 16;
//	DrawText(hdc, action->GetTargetPath().c_str(), -1, &textRect, DT_LEFT | DT_SINGLELINE | DT_NOPREFIX);
//}






	void DrawItem2(LPDRAWITEMSTRUCT pDIS)
	{
		if (pDIS->itemID == -1)
			return;

		// 获取项文本
		wchar_t buffer[256];
		//ListView_GetItemText(hListView, pDIS->itemID, 0, buffer, 256);

		HDC hdc = pDIS->hDC;
		RECT rc = pDIS->rcItem;

		// 背景填充（选中项用暗色）
		COLORREF bgColor = (pDIS->itemState & ODS_SELECTED) ? RGB(30, 30, 60) : RGB(0, 0, 0);
		HBRUSH hBrush = CreateSolidBrush(bgColor);
		FillRect(hdc, &rc, hBrush);
		DeleteObject(hBrush);

		// 文本颜色
		SetTextColor(hdc, RGB(255, 255, 255));
		SetBkMode(hdc, TRANSPARENT);

		DrawText(hdc, buffer, -1, &rc, DT_LEFT | DT_VCENTER | DT_SINGLELINE);
	}


//ListView_SetBkColor(listViewManager.hListView, CLR_NONE);
//ListView_SetTextBkColor(listViewManager.hListView, CLR_NONE);

//InvalidateRect;


			// 返回空刷子以避免绘制默认白底
//static HBRUSH hBrush = CreateSolidBrush(RGB(0, 0, 0)); // 深色背景


测试显示json
// 转为 std::wstring，用于 MessageBoxW 显示
std::wstring wjson;
try {
	wjson = Utf8ToWString(utf8json);
}
catch (const std::exception& e) {
	std::wcerr << L"UTF-8 解析失败：" << Utf8ToWString(e.what()) << std::endl;
	return;
}

// ✅ 此时 wjson 是有效的 null-terminated std::wstring
MessageBoxW(NULL, wjson.c_str(), L"JSON 内容", MB_OK | MB_ICONINFORMATION);



	// 运行命令
	void Invoke() override
	{
		if (IsUwpItem)
		{
			ShellExecuteW(nullptr, L"open", targetFilePath.c_str(), nullptr, nullptr, SW_SHOWNORMAL);
		}
		else
		{
			ShellExecuteW(nullptr, L"open", targetFilePath.c_str(), arguments.empty() ? nullptr : arguments.c_str(),
						workingDirectory.c_str(), SW_SHOWNORMAL);
		}
	}

	// 打开所在文件夹
	void InvokeOpenFolder() const
	{
		const std::wstring folderPath = GetDirectory(targetFilePath);
		if (!folderPath.empty())
		{
			const std::wstring param = L"/select, " + targetFilePath;
			ShellExecuteW(nullptr, L"open", L"explorer.exe", param.c_str(), nullptr, SW_SHOWNORMAL);
		}
	}

	// 打开目标（快捷方式）指向文件夹
	void InvokeOpenGoalFolder() const
	{
		if (GetExtension(targetFilePath) == L".lnk")
		{
			const std::wstring resolvedPath = GetShortcutTarget(targetFilePath);
			if (!resolvedPath.empty())
			{
				const std::wstring param = L"/select, " + resolvedPath;
				ShellExecuteW(nullptr, L"open", L"explorer.exe", param.c_str(), nullptr, SW_SHOWNORMAL);
				return;
			}
		}
		InvokeOpenFolder();
	}

// 不好用，会残留一个 cmd进程
		std::wstring cmdLine = L"cmd.exe /c \"" + targetFilePath + L"\" & exit";


	void Invoke() override
	{
		// std::wstring cmdLine = L"explorer.exe \"" + targetFilePath + L"\"";
		std::wstring cmdLine = L"cmd.exe /c \"" + targetFilePath + L"\" & exit";

		STARTUPINFOW si = { sizeof(si) };
		PROCESS_INFORMATION pi = {};
		si.wShowWindow = SW_HIDE; // 隐藏控制台窗口

		BOOL success = CreateProcessW(
			nullptr,
			&cmdLine[0],
			nullptr,
			nullptr,
			FALSE,
			0,
			nullptr,
			workingDirectory.empty() ? nullptr : workingDirectory.c_str(),
			&si,
			&pi
		);

		if (success)
		{
			CloseHandle(pi.hProcess);
			CloseHandle(pi.hThread);
		}
		else
		{
		std::wstring errorMessage = L"启动失败，请检查路径或权限。" + targetFilePath;
			MainTools::ShowErrorMsgBox(errorMessage);
		}
	}

	void InvokeOpenFolder() const
	{
		const std::wstring folderPath = GetDirectory(targetFilePath);
		if (!folderPath.empty())
		{
			std::wstring param = L"/select,\"" + targetFilePath + L"\"";
			std::wstring cmdLine = L"explorer.exe " + param;

			STARTUPINFOW si = { sizeof(si) };
			PROCESS_INFORMATION pi = {};

			if (CreateProcessW(nullptr, &cmdLine[0], nullptr, nullptr, FALSE, 0, nullptr, nullptr, &si, &pi))
			{
				CloseHandle(pi.hProcess);
				CloseHandle(pi.hThread);
			}
		}
	}

	void InvokeOpenGoalFolder() const
	{
		std::wstring resolvedPath = targetFilePath;

		if (GetExtension(targetFilePath) == L".lnk")
		{
			resolvedPath = GetShortcutTarget(targetFilePath);
			if (resolvedPath.empty())
			{
				InvokeOpenFolder(); // fallback
				return;
			}
		}

		std::wstring param = L"/select,\"" + resolvedPath + L"\"";
		std::wstring cmdLine = L"explorer.exe " + param;

		STARTUPINFOW si = { sizeof(si) };
		PROCESS_INFORMATION pi = {};

		if (CreateProcessW(nullptr, &cmdLine[0], nullptr, nullptr, FALSE, 0, nullptr, nullptr, &si, &pi))
		{
			CloseHandle(pi.hProcess);
			CloseHandle(pi.hThread);
		}
	}


		// wprintf(L"当前索引: %d\n"+justName,0);
		// std::wcout  << justName << std::endl;

		//std::wcout << RunCommand << std::endl;
		//std::wcout << justName << std::endl;

		//OutputDebugStringW(justName.c_str());
		//OutputDebugStringW(RunCommand.c_str());
		//wstring temp = justName + L"\n" + RunCommand;
		//MessageBoxW(NULL, temp.c_str(), L"内容", MB_OK | MB_ICONERROR);




	// 处理 Ctrl+Backspace
	//static void HandleCtrlBackspace(HWND hwnd) {
	//    DWORD start = 0, end = 0;
	//    SendMessage(hwnd, EM_GETSEL, (WPARAM)&start, (LPARAM)&end);
	//    if (start > 0) {
	//        wchar_t text[1024] = { 0 };
	//        GetWindowText(hwnd, text, 1024);

	//        int i = (int)start - 1;
	//        while (i > 0 && text[i] == L' ') i--;       // 跳过空格
	//        while (i > 0 && text[i - 1] != L' ') i--;    // 找到单词边界

	//        SendMessage(hwnd, EM_SETSEL, i, start);
	//        SendMessage(hwnd, EM_REPLACESEL, TRUE, (LPARAM)L"");
	//    }
	//}


// 主进程函数
int APIENTRY wWinMain(_In_ HINSTANCE hInstance,
					_In_opt_ HINSTANCE hPrevInstance,
					_In_ LPWSTR lpCmdLine,
					_In_ int nCmdShow)
{
	// 初始化 Windows 通用控件库中指定的控件类型
	// INITCOMMONCONTROLSEX icex;
	// icex.dwSize = sizeof(INITCOMMONCONTROLSEX);
	// icex.dwICC = ICC_WIN95_CLASSES | ICC_STANDARD_CLASSES | ICC_BAR_CLASSES;  // 可根据需要添加更多
	// InitCommonControlsEx(&icex);


	//wcex.hbrBackground = (HBRUSH)(COLOR_WINDOW + 1);
	// wcex.hbrBackground = nullptr;



	// case WM_PAINT:
	// {
	// 	PAINTSTRUCT ps;
	// 	HDC hdc = BeginPaint(hWnd, &ps);
	//
	// 	HDC hdcMem = CreateCompatibleDC(hdc);
	// 	HBITMAP hbmMem = CreateCompatibleBitmap(hdc, ps.rcPaint.right - ps.rcPaint.left, ps.rcPaint.bottom - ps.rcPaint.top);
	// 	HBITMAP hbmOld = (HBITMAP)SelectObject(hdcMem, hbmMem);
	//
	// 	// 先在内存 DC 中绘制
	// 	HBRUSH hBrush = CreateSolidBrush(COLOR_UI_BG);
	// 	FillRect(hdcMem, &ps.rcPaint, hBrush);
	// 	DeleteObject(hBrush);
	//
	// 	// 在内存 DC 上绘制其他内容...
	//
	// 	// 再一次性拷贝到屏幕
	// 	BitBlt(hdc, ps.rcPaint.left, ps.rcPaint.top,
	// 		ps.rcPaint.right - ps.rcPaint.left,
	// 		ps.rcPaint.bottom - ps.rcPaint.top,
	// 		hdcMem, 0, 0, SRCCOPY);
	//
	// 	// 清理资源
	// 	SelectObject(hdcMem, hbmOld);
	// 	DeleteObject(hbmMem);
	// 	DeleteDC(hdcMem);
	//
	// 	EndPaint(hWnd, &ps);
	// }
	// return 0;



				// wchar_t buffer[256];
				// GetWindowText(hEdit, buffer, 256);
				// int len = GetWindowTextLengthW(hEdit);
				// std::wstring buffer(len, L'\0');
				// if (buffer.capacity() < 100)
				// 	buffer.reserve(100); // 只扩容一次，避免多次 resize 时内存重新分配
				// GetWindowTextW(hEdit, &buffer[0], 100);
				// buffer.resize(wcsnlen(buffer.c_str(), 100)); // 去除尾部空字符

				// buffer.reserve(100);             // 确保容量
				// buffer.resize(100);              // size=100，但不保证内容——我们马上就要覆盖
				if (buffer.size() < 100)

				// buffer.resize(wcsnlen(buffer.c_str(), 100));


	// HRSRC hRes = FindResource(hModule, MAKEINTRESOURCEW(IDR_SETTINGS_JSON), RT_RCDATA);
	//HRSRC hRes = FindResourceW(hModule, MAKEINTRESOURCEW(IDR_SETTINGS_JSON), L"RCDATA");
	//HRSRC hRes = FindResource(hModule, MAKEINTRESOURCE(IDR_SETTINGS_JSON), RT_RCDATA);
	//HRSRC hRes = FindResourceW(hModule, MAKEINTRESOURCEW(IDR_SETTINGS_JSON), L"RCDATA");





//static void ShowErrorMsgBox(const std::string& msg)
//{
//	const DWORD err = GetLastError();
//	char buf[256];
//
//	std::snprintf(buf, sizeof(buf), "%s，错误代码：%lu", msg.c_str(), err);
//	MessageBoxA(nullptr, buf, "错误", MB_OK | MB_ICONERROR);
//}



# -------------------- 修正部分开始 --------------------

# 1. 定义生成的资源文件的路径
set(RESOURCE_FILE ${CMAKE_CURRENT_BINARY_DIR}/windowsproject1.res)

# 2. 添加自定义命令来编译资源
#    这个命令会在 .rc 或 .json 文件变更时执行
add_custom_command(
        OUTPUT ${RESOURCE_FILE}
        COMMAND windres -i ${CMAKE_SOURCE_DIR}/windowsproject1.rc -o ${RESOURCE_FILE} -O coff
        # 明确指出此命令依赖于 .rc 文件和 .json 文件
        DEPENDS
        ${CMAKE_SOURCE_DIR}/windowsproject1.rc
        ${CMAKE_SOURCE_DIR}/settings.json
        COMMENT "Compiling resources with updated settings.json"
)

# 3. 将生成的 .res 文件作为目标的一个源文件
#    这是最关键的一步，它将自定义命令与你的可执行文件目标直接关联起来。
#    当 RESOURCE_FILE 过期时，CMake会先运行上面的自定义命令，然后再链接 WindowsProject1。
target_sources(WindowsProject1 PRIVATE ${RESOURCE_FILE})

# 移除下面的 add_custom_target 和 add_dependencies，它们是多余的。
# add_custom_target(resource_target ALL DEPENDS ${RESOURCE_FILE})
# add_dependencies(WindowsProject1 resource_target)

# -------------------- 修正部分结束 --------------------


#set(RESOURCE_FILE ${CMAKE_CURRENT_BINARY_DIR}/windowsproject1.res)
#
#add_custom_command(
#        OUTPUT ${RESOURCE_FILE}
#        COMMAND windres -i ${CMAKE_SOURCE_DIR}/windowsproject1.rc -o ${RESOURCE_FILE} -O coff
#        DEPENDS ${CMAKE_SOURCE_DIR}/windowsproject1.rc ${CMAKE_SOURCE_DIR}/settings.json
#        COMMENT "Recompiling resources including settings.json"
#)
#
#add_custom_target(resource_target ALL DEPENDS ${RESOURCE_FILE})
#add_dependencies(WindowsProject1 resource_target)
#target_sources(WindowsProject1 PRIVATE ${RESOURCE_FILE})


			// for (const auto& sub : settings2)
			// 	tabSet.insert(utf8_to_wide(sub.subPage));
			
			
			
			// subPages.assign(tabSet.begin(), tabSet.end());


static int GetLabelHeight2(HWND hwnd, std::wstring text, int labelWidth)
{
	RECT rc = {0, 0, labelWidth, 0}; // labelWidth 是你预设的宽度，例如 180 或 300
	// HFONT hFont = (HFONT)GetStockObject(hFontDefault);

	HDC hdc = GetDC(hwnd);
	SelectObject(hdc, hFontDefault);

	DrawTextW(hdc, text.c_str(), -1, &rc, DT_WORDBREAK | DT_CALCRECT);
	int labelHeight = rc.bottom - rc.top;
	ReleaseDC(hwnd, hdc);
	return labelHeight;
}


static int GetLabelHeight3(HWND hwnd, std::wstring text, int labelWidth)
{
	RECT rc = {0, 0, labelWidth, 0};

	HDC hdc = GetDC(hwnd);
	HFONT hOldFont = (HFONT)SelectObject(hdc, hFontDefault);

	// 计算文本绘制所需区域
	DrawTextW(hdc, text.c_str(), -1, &rc, DT_WORDBREAK | DT_CALCRECT);

	int labelHeight = rc.bottom - rc.top;

	// 可选：使用 TextMetrics 校验
	TEXTMETRIC tm;
	GetTextMetrics(hdc, &tm);
	int lineHeight = tm.tmHeight + tm.tmExternalLeading;

	SelectObject(hdc, hOldFont);
	ReleaseDC(hwnd, hdc);
	return labelHeight;
}

static int GetLabelHeight4(HWND hWnd, std::wstring text, int labelWidth)
{
	// PAINTSTRUCT ps;
	// HDC hdc = BeginPaint(hWnd, &ps);
	HDC hdc = GetDC(hWnd);

	// 获取客户区大小
	RECT clientRect;
	GetClientRect(hWnd, &clientRect);

	// 设置一个最大宽度为200的矩形
	RECT drawRect = {0, 0, labelWidth, clientRect.bottom};

	// 文本内容
	// LPCWSTR text = L"我是来自非洲的姑娘。心中向往神秘的东方,背起行囊寻找梦想,那是龙的故乡这里的人纯朴善良,淡淡微笑挂脸庞";

	// 复制 drawRect 以便计算文本高度
	RECT calcRect = drawRect;

	// 计算文本所需高度
	DrawTextW(hdc, text.c_str(), -1, &calcRect, DT_CENTER | DT_WORDBREAK | DT_CALCRECT | DT_EDITCONTROL);
	int textHeight = calcRect.bottom - calcRect.top;

	// 垂直居中：重新设置 drawRect 的 top 和 bottom
	int verticalOffset = (clientRect.bottom - textHeight) / 2;
	drawRect.top = verticalOffset;
	drawRect.bottom = verticalOffset + textHeight;

	// 设置背景透明（可选）
	SetBkMode(hdc, TRANSPARENT);

	// 实际绘制文本
	DrawTextW(hdc, text.c_str(), -1, &drawRect, DT_CENTER | DT_WORDBREAK | DT_EDITCONTROL);

	// EndPaint(hWnd, &ps);

	return drawRect.bottom - drawRect.top + 10;
}


				// HWND hContainer = CreateWindowExW(0, L"STATIC", nullptr,
				// 								WS_CHILD | WS_VISIBLE,
				// 								100, 0, 600, 380, hwnd, nullptr, nullptr, nullptr);



// 设置滚动范围xxuxu
static void UpdateScrollRange2(HWND hwnd, int contentHeight)
{
	const int viewHeight = 380; // 容器高度
	int maxScroll = MyMax(0, contentHeight - viewHeight);
	SetScrollRange(hwnd, SB_VERT, 0, maxScroll, TRUE);
	SetScrollPos(hwnd, SB_VERT, 0, TRUE);
}



		// SetBkMode(hdcStatic, OPAQUE);
		// SetBkColor(hdcStatic, COLOR_UI_BG);




// CLEARTYPE_QUALITY, VARIABLE_PITCH, L"微软雅黑");




	// HWND hWnd = CreateWindowW(L"SettingsWndClass", L"设置",
	// 	WS_OVERLAPPED | WS_CAPTION | WS_SYSMENU,
	// 	CW_USEDEFAULT, CW_USEDEFAULT, 480, 350,
	// 	hParent, nullptr, hInstance, nullptr);

	//HWND hWnd = CreateWindowW(L"SettingsWndClass", L"设置",
	//	WS_POPUP | WS_CAPTION | WS_SYSMENU | WS_MINIMIZEBOX | WS_EX_ACCEPTFILES,
	//	 //WS_POPUP | WS_VISIBLE,
	//	CW_USEDEFAULT, CW_USEDEFAULT, 480, 350,
	//	hParent, nullptr, hInstance, nullptr);


	case WM_CLOSE:
		DestroyWindow(hwnd);
		break;
	case WM_DESTROY:
		PostQuitMessage(0);
		break;



// Subclass procedure to handle hotkey input on an EDIT control
static LRESULT CALLBACK HotkeySubclassProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam, UINT_PTR uIdSubclass,
											DWORD_PTR dwRefData)
{
	switch (uMsg)
	{
	case WM_KEYDOWN:
	case WM_SYSKEYDOWN:
		{
			std::wstring hotkeyString;
			// 1. Check for modifier keys
			if (GetKeyState(VK_CONTROL) & 0x8000) hotkeyString += L"Ctrl + ";
			if (GetKeyState(VK_SHIFT) & 0x8000) hotkeyString += L"Shift + ";
			if (GetKeyState(VK_MENU) & 0x8000) hotkeyString += L"Alt + ";

			UINT vkCode = static_cast<UINT>(wParam);
			std::wstring keyStr;

			// 2. Ignore presses of modifier keys by themselves
			if (vkCode == VK_CONTROL || vkCode == VK_SHIFT || vkCode == VK_MENU || vkCode == VK_LWIN || vkCode == VK_RWIN)
			{
				SetWindowTextW(hWnd, hotkeyString.c_str()); // Show only modifiers so far
			}
			else
			{
				// std::wstring keyName = VKCodeToString(vkCode);
				// std::wstring keyName ;
				// if (!keyName.empty()) {
				//     hotkeyString += keyName;
				// }

				wchar_t keyName[64] = {};
				UINT scanCode = MapVirtualKey(vkCode, MAPVK_VK_TO_VSC) << 16;
				GetKeyNameTextW(scanCode, keyName, 64);
				hotkeyString += keyName;

				SetWindowTextW(hWnd, hotkeyString.c_str());
			}
			// 3. We handled this message; prevent default processing
			return 0;
		}

	// Clear the box on Backspace or Delete for user convenience
	case WM_KEYUP:
		{
			if (wParam == VK_BACK || wParam == VK_DELETE)
			{
				SetWindowTextW(hWnd, L"");
			}
			break;
		}

	case WM_KILLFOCUS:
		{
			// 如果用户仅按下修饰符单击，请清除框。
			wchar_t buffer[128];
			GetWindowTextW(hWnd, buffer, 128);
			std::wstring currentText = buffer;
			if (currentText == L"Ctrl + " || currentText == L"Shift + " || currentText == L"Alt + " ||
				currentText == L"Ctrl + Shift + " || currentText == L"Ctrl + Alt + " || currentText == L"Shift + Alt + "
				||
				currentText == L"Ctrl + Shift + Alt + ")
			{
				SetWindowTextW(hWnd, L"");
			}
			break;
		}
	}
	// For all other messages, use the default procedure
	return DefSubclassProc(hWnd, uMsg, wParam, lParam);
}


	if (!RegisterHotKey(s_mainHwnd, HOTKEY_ID_TOGGLE_MAIN_PANEL, MOD_ALT, 0x4B))
	{
		const DWORD error = GetLastError();
		if (error == ERROR_HOTKEY_ALREADY_REGISTERED)
		{
			MessageBox(nullptr, L"热键 Alt+K 已被占用", L"错误", MB_OK | MB_ICONERROR);
		}
		else
		{
			std::wstringstream ss;
			ss << L"热键注册失败，错误代码：" << error;
			MessageBox(nullptr, ss.str().c_str(), L"错误", MB_OK | MB_ICONERROR);
		}
	}

				// if (GetKeyState(VK_MENU) < 0) currentModifiers |= MOD_ALT_KEY;
				// if (GetKeyState(VK_CONTROL) < 0) currentModifiers |= MOD_CTRL_KEY;
				// if (GetKeyState(VK_SHIFT) < 0) currentModifiers |= MOD_SHIFT_KEY;
				// if (GetKeyState(VK_LWIN) < 0 || GetKeyState(VK_RWIN) < 0) currentModifiers |= MOD_WIN_KEY;





	// 假设 words 是用户输入的一个字符串，而不是分割后的单词列表
	// const int score_threshold = 75; // 相似度阈值 (0-100)
	const int score_threshold = 40; // 相似度阈值 (0-100)

	for (const auto& action : allActions)
	{
		const std::wstring& runCommand = action->RunCommand;

		// 使用 token_sort_ratio 可以忽略单词顺序，更灵活
		// 如果你还想匹配部分内容，可以用 partial_ratio
		double score = rapidfuzz::fuzz::token_sort_ratio(runCommand, keyword);

		if (score >= score_threshold)
		{
			const std::wstring& title = action->GetTitle();
			const std::wstring& subtitle = action->GetSubtitle();

					LVITEM item = {};
					item.mask = LVIF_TEXT | LVIF_IMAGE;
					item.iItem = ListView_GetItemCount(hListView);
					item.pszText = const_cast<LPWSTR>(title.c_str());
					item.iImage = (action->iImageIndex == -1) ? 0 : action->iImageIndex;
			
					ListView_InsertItem(hListView, &item);
					ListView_SetItemText(hListView, item.iItem, 1, const_cast<LPWSTR>(subtitle.c_str()));

			filteredActions.push_back(action);
			matchedCount++;
			if (matchedCount >= 7)
				break;
		}
	}


		{
			"key":"pref_exact_match",
			"title":"完整匹配",
			"type":"bool",
			"subPage":"feature",
			"defValue":false
		},




子控件设置为透明的效果很不好，非常不建议
	case WM_CTLCOLOREDIT:
	case WM_CTLCOLORSTATIC:
SetBkMode(hdc, TRANSPARENT);
return (INT_PTR)GetStockObject(NULL_BRUSH);





		case WM_PAINT:
			{
				// 开始完全自定义绘制
				PAINTSTRUCT ps;
				HDC hdc = BeginPaint(hwnd, &ps);

				// 创建GDI+绘图对象
				Gdiplus::Graphics graphics(hdc);
				graphics.SetSmoothingMode(Gdiplus::SmoothingMode::SmoothingModeHighQuality);
				graphics.SetInterpolationMode(Gdiplus::InterpolationMode::InterpolationModeHighQualityBicubic);
				graphics.SetTextRenderingHint(Gdiplus::TextRenderingHintClearTypeGridFit);
				Gdiplus::SolidBrush brush(Gdiplus::Color(0xFF, 0x22, 0x22, 0x22)); // 文本颜色
            
				// 准备绘制文本
				TCHAR buffer[1024];
				GetWindowText(hwnd, buffer, sizeof(buffer)/sizeof(buffer[0]));
            
				// 获取字体信息
				HFONT hFont = (HFONT)SendMessage(hwnd, WM_GETFONT, 0, 0);
				Gdiplus::Font font(hdc, hFont);
            
				// 计算绘制位置（考虑滚动位置和光标）
				DWORD firstChar = (DWORD)SendMessage(hwnd, EM_CHARFROMPOS, 0, 0);
				int xOffset = LOWORD(SendMessage(hwnd, EM_POSFROMCHAR, firstChar, 0));
            
				// 绘制背景
				RECT rc;
				GetClientRect(hwnd, &rc);
				// 创建 GDI+ 画刷
				Gdiplus::SolidBrush bgBrush(Gdiplus::Color(0xFF, 0x88, 0x88, 0x88));
				graphics.FillRectangle(&bgBrush, rc.left, rc.top, rc.right - rc.left, rc.bottom - rc.top);
				// graphics.FillRectangle(&brush, rc.left, rc.top, rc.right - rc.left, rc.bottom - rc.top);

            
				// 设置文本布局
				Gdiplus::StringFormat format;
				format.SetTrimming(Gdiplus::StringTrimmingNone);
				format.SetFormatFlags(Gdiplus::StringFormatFlagsLineLimit);
            
				// 绘制文本
				graphics.DrawString(
					buffer, -1, &font,
					Gdiplus::RectF(-xOffset, 0, rc.right + abs(xOffset), rc.bottom),
					&format, &brush);
				
				EndPaint(hwnd, &ps);
				return 0; // 完全处理，阻止默认绘制
			}
		case WM_ERASEBKGND:
			return 1; // 阻止默认背景擦除


		default: break;
		}
		// ctrl+o 会发出beep声，解决不了，很多原生程序的编辑框也会这样子
		return DefSubclassProc(hwnd, msg, wParam, lParam);
	}


	// --- 4. 强制重绘 ---
	// 让所有更改生效
	// InvalidateRect(hWnd, NULL, TRUE);
	// UpdateWindow(hWnd); // 立即重绘
	// RedrawWindow(hWnd, NULL, NULL, RDW_INVALIDATE | RDW_UPDATENOW | RDW_ERASE | RDW_ALLCHILDREN);
	// ShowWindow(hWnd,SW_FORCEMINIMIZE);
	// ShowWindow(hWnd,SW_SHOW);

	// LONG style = GetWindowLong(hWnd, GWL_STYLE);
	// SetWindowLong(hWnd, GWL_STYLE, style & ~WS_CLIPCHILDREN);
	// RedrawWindow(hWnd, NULL, NULL, 
	// 	RDW_INVALIDATE | RDW_ERASE | RDW_ALLCHILDREN | RDW_UPDATENOW);
	// SetWindowLong(hWnd, GWL_STYLE, style);




		case WM_ERASEBKGND:
			{
				HDC hdc = (HDC)wParam;
				RECT rc;
				GetClientRect(hwnd, &rc);
				int width = rc.right - rc.left;
				int height = rc.bottom - rc.top;

				// GDI+ Bitmap + Graphics
				Gdiplus::Bitmap bitmap(width, height, PixelFormat32bppARGB);
				Gdiplus::Graphics gBmp(&bitmap);
				gBmp.SetSmoothingMode(Gdiplus::SmoothingModeAntiAlias);

				// 获取父窗口的位置关系
				// HWND hwndParent = (HWND)dwRefData;
				HWND hwndParent = GetParent(hwnd);
				POINT pt = { 0, 0 };
				MapWindowPoints(hwnd, hwndParent, &pt, 1);

				// 创建 GDI HDC 绑定 Graphics，供父窗口画图
				HDC hdcMem = gBmp.GetHDC();

				// 父窗口绘制内容到 gBmp 对应的 HDC
				SendMessage(hwndParent, WM_PRINT, (WPARAM)hdcMem,
							PRF_CLIENT | PRF_ERASEBKGND | PRF_NONCLIENT);

				gBmp.ReleaseHDC(hdcMem); // 必须释放

				// 显示绘制结果
				Gdiplus::Graphics g(hdc);
				g.SetSmoothingMode(Gdiplus::SmoothingModeAntiAlias);
				g.DrawImage(&bitmap, 0, 0, width, height);

				return TRUE;
			}











	// case WM_CTLCOLOREDIT:
	// case WM_CTLCOLORSTATIC:
	// 	{
	// 		// 用于 编辑框的背景颜色
	// 		HDC hdc = reinterpret_cast<HDC>(wParam);
	// 		// 设置字体颜色
	// 		if (g_skinJson!=nullptr)
	// 		{
	// 			std::string fontColorHex = g_skinJson.value("editbox_font_color", "#000000");
	// 			SetTextColor(hdc, HexToCOLORREF(fontColorHex));
	//
	// 			// 设置背景
	// 			// SetBkMode(hdc, TRANSPARENT); // 使背景透明，这样才能看到父窗口的背景
	// 			
	//
	// 			// 返回一个空画刷，因为我们希望背景是透明的
	// 			// 如果需要纯色背景，则创建并返回对应颜色的画刷
	// 			std::string editBgColorHex = g_skinJson.value("editbox_bg_color", "");
	// 			if (!editBgColorHex.empty()) {
	// 				// static HBRUSH hEditBrush = nullptr;
	// 				// if(hEditBrush) DeleteObject(hEditBrush); // 删除旧画刷
	// 				// hEditBrush = CreateSolidBrush(HexToCOLORREF(editBgColorHex));
	// 				// return (INT_PTR)hEditBrush;
	// 			SetBkColor(hdc, RGB(255, 255, 255)); // 白色背景
	// 				static HBRUSH hBrush = CreateSolidBrush(COLOR_UI_BG); // 深色背景
	// 				return reinterpret_cast<INT_PTR>(hBrush);
	// 			}else
	// 			{
	// 			SetBkColor(hdc, RGB(255, 255, 255)); // 白色背景
	// 				static HBRUSH hBrush = CreateSolidBrush(HexToCOLORREF(editBgColorHex)); // 深色背景
	// 				return reinterpret_cast<INT_PTR>(hBrush);
	// 			}
	//
	// 			return (INT_PTR)GetStockObject(NULL_BRUSH);
	// 		}else
	// 		{
	// 			// 设置背景透明
	// 			static HBRUSH hBrush = CreateSolidBrush(COLOR_UI_BG); // 深色背景
	// 			return reinterpret_cast<INT_PTR>(hBrush);
	// 		}
	// 	}


	// case WM_CTLCOLOREDIT:
	// case WM_CTLCOLORSTATIC:
	// 	{
	// 		if (g_skinJson!=nullptr){
	// 			HDC hdc = reinterpret_cast<HDC>(wParam);
	//
	// 			// 设置字体颜色
	// 			// std::string fontColorHex = g_skinJson.value("editbox_font_color", "#000000");
	// 			std::string fontColorHex = "#111111";
	// 			SetTextColor(hdc, HexToCOLORREF(fontColorHex));
	//
	// 			// 设置背景
	// 			// SetBkMode(hdc, TRANSPARENT); // 使背景透明，这样才能看到父窗口的背景
	// 						SetBkMode(hdc, OPAQUE);
	// 			SetBkColor(hdc, RGB(255, 255, 255)); // 白色背景
	//
	// 			// 返回一个空画刷，因为我们希望背景是透明的
	// 			// 如果需要纯色背景，则创建并返回对应颜色的画刷
	// 			std::string editBgColorHex = g_skinJson.value("editbox_bg_color", "");
	// 			if (!editBgColorHex.empty())
	// 			{
	// 				static HBRUSH hEditBrush = nullptr;
	// 				if (hEditBrush) DeleteObject(hEditBrush); // 删除旧画刷
	// 				hEditBrush = CreateSolidBrush(HexToCOLORREF(editBgColorHex));
	// 				return (INT_PTR)hEditBrush;
	// 			}
	//
	// 			return (INT_PTR)GetStockObject(NULL_BRUSH);
	// 		}
	// 	}
	// 	break;
	// case WM_CTLCOLORSTATIC:
	// case WM_CTLCOLOREDIT:
	// 	{
	// 		// 这个分支处理 hEdit 控件的背景
	// 		HDC hdc = (HDC)wParam;
	// 		HWND hCtrl = (HWND)lParam;
	// 		SetBkMode(hdc, OPAQUE);
	// 		SetGraphicsMode(hdc, GM_COMPATIBLE);
	// 		if (hCtrl == hEdit) {
	// 			// 如果有皮肤配置，从皮肤JSON中获取颜色
	// 			if (g_skinJson != nullptr) {
	// 				// std::string fontColorHex = g_skinJson.value("editbox_font_color", "#222222");
	// 				std::string fontColorHex = "#222222";
	// 				std::string bgColorHex = g_skinJson.value("editbox_bg_color", "#FFFFFF"); // 例如，我们想要一个纯白背景
	//
	// 				SetTextColor(hdc, HexToCOLORREF(fontColorHex));
	// 				SetBkColor(hdc, HexToCOLORREF(bgColorHex));
	//
	// 				// 创建并返回一个静态画刷，避免每次都创建导致资源泄露
	// 				static HBRUSH hEditBrush = CreateSolidBrush(HexToCOLORREF(bgColorHex));
	// 				return (INT_PTR)hEditBrush;
	// 			}
	// 			else {
	// 				// 默认行为
	// 				SetTextColor(hdc, RGB(10, 10, 10)); // 黑色字体
	// 				// SetBkColor(hdc, RGB(255, 255, 255)); // 白色背景
	// 				// SetBkColor(hdc, RGB(255, 255, 255)); // 白色背景
	// 				SetBkColor(hdc, RGB(10, 10, 10)); // 黑色字体
	//
	// 				static HBRUSH hDefaultBrush = CreateSolidBrush(RGB(255, 255, 255));
	// 				return (INT_PTR)hDefaultBrush;
	// 			}
	// 		}
	// 		break; // 不要忘记 break
	// 	}
	
	case WM_ERASEBKGND:
		{
			// if (g_skinJson!=nullptr&& g_backgroundImage==nullptr)
			// {
			// 	std::string bgColorStr=g_skinJson.value("window_bg_color", "#FFFFFF");
			// 	if (bgColorStr.empty())
			// 	{
			// 		return 1;
			// 	}
			// 	
			// 	HDC hdc = (HDC)wParam;
			// 	RECT clientRect;
			// 	GetClientRect(hWnd, &clientRect);
			//
			// 	// Default to white color if the JSON object is not available or the key is missing
			// 	COLORREF bgColor = RGB(255, 255, 255);
			// 	bgColor = HexToCOLORREF(bgColorStr);
			//
			// 	// Create a temporary brush, fill the background, and delete the brush
			// 	HBRUSH hBgBrush = CreateSolidBrush(bgColor);
			// 	FillRect(hdc, &clientRect, hBgBrush);
			// 	DeleteObject(hBgBrush);
			// }
			return 1; // Return non-zero to indicate you have handled erasing the background
		}



	// hEdit = CreateWindowExW(
	// 	WS_EX_CLIENTEDGE,       // 可以给一点边框样式
	// 	MSFTEDIT_CLASS,         // ✨ 使用 Rich Edit 的类名
	// 	L"",                    // 初始文本
	// 	WS_CHILD | WS_VISIBLE | ES_LEFT | ES_AUTOHSCROLL,
	// 	10, 10, 580, 35,
	// 	hWnd,
	// 	reinterpret_cast<HMENU>(1),
	// 	hInstance,
	// 	nullptr
	// );
	// 1. ✨ 设置不透明的背景颜色
	// wParam 设置为 FALSE 表示 lParam 是一个 COLORREF
	// 这里的颜色就是纯白色，完全不透明
	// SendMessage(hEdit, EM_SETBKGNDCOLOR, FALSE, (LPARAM)RGB(255, 255, 255));
	// CHARFORMAT2W cf{};
	// cf.cbSize = sizeof(cf);
	// cf.dwMask = CFM_COLOR | CFM_FACE | CFM_SIZE | CFM_WEIGHT | CFM_BACKCOLOR; // 我们要设置颜色、字体、大小、粗细 和 文字背景色
	//
	// cf.crTextColor = RGB(10, 10, 10); // 文本颜色
	// cf.crBackColor = RGB(255, 255, 255); 
	//
	// cf.yHeight = 11 * 20; // 字体大小，单位是缇(twip), 1磅=20缇
	// cf.wWeight = FW_NORMAL; // 正常粗细
	// wcscpy_s(cf.szFaceName, L"Microsoft YaHei UI"); // 字体
	//
	// SendMessage(hEdit, EM_SETCHARFORMAT, SCF_ALL, (LPARAM)&cf);
	// SendMessageW(hEdit, EM_SETCUEBANNER, TRUE,
	// 	reinterpret_cast<LPARAM>(utf8_to_wide(
	// 		settingsMap["pref_search_box_placeholder"].defValue.get<std::string>()).c_str()));



// 透明键玩法
			// HBRUSH greenBrush = CreateSolidBrush(RGB(80, 81, 82));
			// FillRect(hdc, &ps.rcPaint, greenBrush);
			// DeleteObject(greenBrush);


		// std::wstringstream wss;
		// wss << L"绘制背景." << (rcClient.right - rcClient.left) << L"x" << (rcClient.bottom - rcClient.top) << L"\t" << lplvcd->clrText<< L"\t" << lplvcd->dwItemType<< L"\t" << lplvcd->nmcd.hdc;
		// Println(wss.str());

	// if (fontsInitialized) return;
	// Gdiplus::FontFamily fontFamily(L"Segoe UI");
	// titleFont = std::make_unique<Gdiplus::Font>(&fontFamily, 14.0f, Gdiplus::FontStyleBold, Gdiplus::UnitPixel);
	// subFont = std::make_unique<Gdiplus::Font>(&fontFamily, 12.0f, Gdiplus::FontStyleRegular, Gdiplus::UnitPixel);
	// whiteBrush = std::make_unique<Gdiplus::SolidBrush>(Gdiplus::Color(255, 255, 255, 255));
	// blackBrush = std::make_unique<Gdiplus::SolidBrush>(Gdiplus::Color(255, 0, 0, 0));
	// grayBrush = std::make_unique<Gdiplus::SolidBrush>(Gdiplus::Color(255, fontColorGray, fontColorGray, fontColorGray));

		// throw std::runtime_error("设置基础文件不存在");
		// exit(1);


			const wchar_t* name = MsgName(message);
			if (name) {
				Println( name);
			}


 static const wchar_t* MsgName(UINT m) {
 #define CASE(x) case x: return L#x
 	switch (m) {
 		CASE(WM_NULL);       CASE(WM_CREATE);   CASE(WM_DESTROY);
 		CASE(WM_MOVE);       CASE(WM_SIZE);     CASE(WM_PAINT);
 		CASE(WM_CLOSE);      CASE(WM_QUIT);     CASE(WM_TIMER);
 		CASE(WM_SETFOCUS);   CASE(WM_KILLFOCUS);
 		CASE(WM_KEYDOWN);    CASE(WM_KEYUP);    CASE(WM_CHAR);
 		CASE(WM_MOUSEMOVE);  CASE(WM_LBUTTONDOWN); CASE(WM_LBUTTONUP);
 		CASE(WM_RBUTTONDOWN);CASE(WM_RBUTTONUP);CASE(WM_MOUSEWHEEL);
 		CASE(WM_COMMAND);    CASE(WM_NOTIFY);
 	default: return nullptr;
 	}
 #undef CASE
 }


    char *args22[] = {
            (char*)"program_name",
            (char*)"-p",
            (char*)"D:\\Download3\\ES-1.1.0.30.src\\ES-1.1.0.30\\src",
//            (char*)"D:\\DengYuhua\\",
            nullptr
    };

    Everything_SetSearchW(L"hello1");
    Everything_QueryW(TRUE);
    DWORD num = Everything_GetNumResults();

    for (DWORD i = 0; i < num; i++) {
        wchar_t buf[MAX_PATH];
        Everything_GetResultFullPathNameW(i, buf, MAX_PATH);
        MessageBoxW(NULL, buf, L"Search Result", MB_OK);
    }


//    int temp=main22(0,args22);
//    std::string temp2;
//    temp2.append("done");
//    temp2.append(std::to_string(temp));
    
//    std::cout << temp2 << std::endl;



void TraverseFilesForEverythingSDK2(
        const std::wstring& folderPath,
        const ListedRunnerPlugin::TraverseOptions& options,
        std::vector<std::shared_ptr<RunCommandAction>>& outActions)
{
    if (!fs::exists(folderPath) || !fs::is_directory(folderPath)) return;

    auto addFile = [&](const fs::path& path)
    {
        std::wstring filename = path.stem().wstring();
        if (shouldExclude(options, filename)) return;

        if (const auto it = options.renameMap.find(filename); it != options.renameMap.end())
            filename = it->second;

        outActions.push_back(std::make_shared<RunCommandAction>(
                filename, path.wstring(), false, true, path.parent_path().wstring()
        ));
    };

    // 构造搜索正则，例如: (\\.exe|\\.txt)$
    std::wstringstream regex_stream;
    if (!options.extensions.empty())
    {
        regex_stream << L"(";
        for (size_t i = 0; i < options.extensions.size(); ++i)
        {
            std::wstring ext = options.extensions[i];
            if (!ext.empty() && ext[0] != L'.') ext = L"." + ext;
            regex_stream << L"\\" << ext;
            if (i < options.extensions.size() - 1) regex_stream << L"|";
        }
        regex_stream << L")$";
    }

    // 构造搜索关键字：限制路径 + 正则扩展名
    std::wstringstream search_query;
    search_query << L"\"" << folderPath << L"\" ";
    if (!options.extensions.empty())
        search_query << L"regex:" << regex_stream.str();

    std::wcout << search_query.str() << std::endl;
    
    // 使用 Everything SDK
    Everything_SetSearchW(search_query.str().c_str());
//    Everything_SetMatchPath(TRUE);
    Everything_SetRegex(TRUE);
    Everything_QueryW(TRUE);

    DWORD numResults = Everything_GetNumResults();
    fs::path searchFolderPath(folderPath);

    for (DWORD i = 0; i < numResults; i++)
    {
        wchar_t fullPath[MAX_PATH];
        Everything_GetResultFullPathNameW(i, fullPath, MAX_PATH);

        fs::path filePath(fullPath);

        if (!options.recursive)
        {
            if (filePath.parent_path() != searchFolderPath)
                continue;
        }
//        std::cout << filePath << std::endl;
        addFile(filePath);
    }
    // 查询结束后，最好恢复默认设置，以免影响后续其他可能的查询
    if (!options.extensions.empty())
    {
        Everything_SetRegex(FALSE);
    }

}


[[maybe_unused]] void TrayMenuManager::Init2(HWND parent, HINSTANCE hInstance)
{
	// 初始化托盘图标
	ZeroMemory(&nid, sizeof(NOTIFYICONDATA));
	nid.cbSize = sizeof(NOTIFYICONDATA);
	nid.hWnd = parent;
	nid.uID = TRAY_ICON_ID;
	nid.uFlags = NIF_MESSAGE | NIF_ICON | NIF_TIP;
	nid.uCallbackMessage = WM_TRAYICON;
	nid.hIcon = LoadIcon(hInstance, MAKEINTRESOURCE(IDI_WINDOWSPROJECT1));
	hInstance2 = hInstance;
	wcscpy_s(nid.szTip, L"My App");
	Shell_NotifyIcon(NIM_ADD, &nid);

	// 创建托盘菜单
	hTrayMenu = CreatePopupMenu();
	AppendMenu(hTrayMenu, MF_STRING, TRAY_MENU_ID_SHOW_WINDOW, L"打开主窗口(&C)");
	AppendMenu(hTrayMenu, MF_SEPARATOR, 0, nullptr); // 插入分隔线
	AppendMenu(hTrayMenu, MF_STRING, TRAY_MENU_ID_HELP, L"帮助文档(&H)");
	// 🔹 创建一个子菜单
	HMENU hSubMenu = CreatePopupMenu();
	AppendMenu(hSubMenu, MF_STRING, TRAY_MENU_ID_EDIT_CONFIG, L"编辑配置文件（记事本）(&O)");
	AppendMenu(hSubMenu, MF_STRING, TRAY_MENU_ID_OPEN_FOLDER, L"在资源管理器打开路径(&I)");
	AppendMenu(hSubMenu, MF_STRING, TRAY_MENU_ID_GITHUB, L"打开 Github 主页");
	AppendMenu(hSubMenu, MF_SEPARATOR, 0, nullptr); // 插入分隔线
	AppendMenu(hSubMenu, MF_STRING, TRAY_MENU_ID_RESTART, L"重启软件(&R)");

//	AppendMenu(hTrayMenu, MF_STRING, TRAY_MENU_ID_RESTART, L"重启软件");
// 把子菜单加到主菜单
	AppendMenu(hTrayMenu, MF_SEPARATOR, 0, nullptr); // 插入分隔线
	AppendMenu(hTrayMenu, MF_POPUP, (UINT_PTR)hSubMenu, L"更多...(&M)");

	AppendMenu(hTrayMenu, MF_STRING, TRAY_MENU_ID_SETTINGS, L"设置(&S)");
	AppendMenu(hTrayMenu, MF_STRING, TRAY_MENU_ID_EXIT, L"退出(&E)");
}

enum class SettingType {
	BOOL,
	STRING,
	INT,
	FLOAT,
	LIST,
	HOTKEYSTRING,
	BUTTON,
	TEXT,
};


	int value_int;
	bool value_bool;
	std::string value_string;
	SettingType type;
	std::any getValue(){
		switch (type) {
			case SettingType::BOOL:{
				return value_bool;
			}
			case SettingType::STRING:
				return value_string;
			case SettingType::INT:
				return value_int;
			case SettingType::FLOAT:
				break;
			case SettingType::LIST:
				break;
			case SettingType::HOTKEYSTRING:
				break;
			case SettingType::BUTTON:
				break;
			case SettingType::TEXT:
				break;
		}
		return "";
	}


//inline std::vector<SettingItem> ParseConfig(const std::string& configStr) {
//    nlohmann::json j = nlohmann::json::parse(configStr);
//    std::vector<SettingItem> settings;
//    for (auto& item : j["prefList"]) {
//        settings.push_back({
//            item["key"].get<std::string>(),
//            item["type"].get<std::string>(),
//            item["subPage"].get<std::string>(),
//            item["defValue"]
//            });
//    }
//    return settings;
//}

/**
 * 更改tab页，但是btn不会相应的更改高亮
 * @param tabName 
 */
static void SwitchToTab2(const std::wstring &tabName) {
	int newIdx = FindTabIndexByName(tabName);
	int oldIdx = currentSubPageIndex;
	if (newIdx >= 0 && newIdx < static_cast<int>(tabContainers.size())) {
		ShowWindow(tabContainers[currentSubPageIndex], SW_HIDE);
		ShowWindow(tabContainers[newIdx], SW_SHOW);
		currentSubPageIndex = newIdx;
		// TODO: UpdateTabButtonSelection(newIdx); - Function removed
	}
}




static void saveConfig2(const std::vector<std::wstring> &subPages, const std::vector<SettingItem> &settings2,
						const std::vector<std::vector<HWND>> &hCtrlsByTab) {
	nlohmann::json newConfig;
	newConfig["version"] = 1;
	newConfig["prefList"] = nlohmann::json::array();

	// 遍历每个tab
	for (size_t tabIdx = 0; tabIdx < subPages.size(); ++tabIdx) {
		int ctrlIdx = 0;
		for (size_t i = 0; i < settings2.size(); ++i) {
			const auto &item = settings2[i];
			if (utf8_to_wide(item.subPage) != subPages[tabIdx])
				continue;

			nlohmann::json obj;
			obj["key"] = item.key;
			obj["type"] = item.type;
			obj["subPage"] = item.subPage;

			HWND hCtrl = hCtrlsByTab[tabIdx][static_cast<size_t>(ctrlIdx + 1)];
			if (item.type == "bool") {
				bool checked = GetSwitchState(hCtrl);
				obj["defValue"] = checked;
			} else if (item.type == "string") {
				wchar_t buf[256];
				GetWindowTextW(hCtrl, buf, 256);
				std::wstring ws(buf);
				obj["defValue"] = wide_to_utf8(ws);
			} else if (item.type == "stringArr") {
				wchar_t buf[1024];
				GetWindowTextW(hCtrl, buf, 1024);
				std::wstring ws(buf);
				std::vector<std::string> arr;
				size_t start = 0;
				while (start < ws.size()) {
					size_t end = ws.find_first_of(L"\r\n", start);
					if (end == std::wstring::npos) end = ws.size();
					std::wstring line = ws.substr(start, end - start);
					if (!line.empty())
						arr.push_back(wide_to_utf8(line));
					start = ws.find_first_not_of(L"\r\n", end);
					if (start == std::wstring::npos) break;
				}
				obj["defValue"] = arr;
			} else if (item.type == "list") {
				int selIdx = (int) SendMessage(hCtrl, CB_GETCURSEL, 0, 0);
				std::string val = item.entryValues[selIdx];
				obj["defValue"] = val;
			} else if (item.type == "long") {
				wchar_t buf[32];
				GetWindowTextW(hCtrl, buf, 32);
				obj["defValue"] = _wtol(buf); // 宽字符转 long
			} else if (item.type == "hotkeystring") {
				wchar_t buf[256];
				GetWindowTextW(hCtrl, buf, 256);
				std::string hotkeyStr = wide_to_utf8(std::wstring(buf));
				obj["defValue"] = _wtol(buf); // 宽字符转 long
			} else if (item.type == "button") {
				// Button类型保持原始的defValue（action名称）
				obj["defValue"] = item.defValue;
			}

			newConfig["prefList"].push_back(obj);
			ctrlIdx += 2; // hLabel, hCtrl
		}
	}
	// 你可以保存 newConfig.dump(4) 到文件
	std::string temp = newConfig.dump(4);
	ShowErrorMsgBox(temp);
	// MessageBoxW(hwnd, L"保存成功（实际存储代码请补全）", L"提示", MB_OK);
}



//static bool IsChinese(const std::wstring& str)
//{
//return std::ranges::any_of(str, [](wchar_t ch)
//{
//	return ch >= 0x4E00 && ch <= 0x9FFF;
//});
//	for (wchar_t ch : str)
//	{
//		if (ch >= 0x4E00 && ch <= 0x9FFF)
//			return true;
//	}
//	return false;
//}








// 更新快捷方式列表
static void UpdateShortcutList2(int selectedIndex) {
	// 清空列表
	ListView_DeleteAllItems(g_shortcutListView);

	if (selectedIndex < 0 || selectedIndex >= static_cast<int>(g_runnerConfigs.size())) {
		return;
	}

	const TraverseOptions &config = g_runnerConfigs[selectedIndex];
	std::vector<std::wstring> shortcuts;
	TraverseFilesForEverythingSDK(config.folder, config, [&](const std::wstring &name,
															 const std::wstring &fullPath,
															 const std::wstring &parent,
															 const std::wstring &ext) {
		shortcuts.push_back(fullPath);
	});

	// 添加快捷方式到列表视图
	SendMessage(g_shortcutListView, WM_SETREDRAW, FALSE, 0); // 暂停重绘
	for (size_t i = 0; i < shortcuts.size(); ++i) {
		LVITEMW item = {};
		item.mask = LVIF_TEXT;
		item.iItem = static_cast<int>(i);
		item.iSubItem = 0;
		item.pszText = const_cast<LPWSTR>(shortcuts[i].c_str());
		//ListView_InsertItem(g_shortcutListView, &item);
	}
	ListView_SetItemCountEx(g_shortcutListView, (int)shortcuts.size(), LVSICF_NOINVALIDATEALL);

	SendMessage(g_shortcutListView, WM_SETREDRAW, TRUE, 0);  // 恢复重绘
	InvalidateRect(g_shortcutListView, nullptr, TRUE);       // 立即刷新
}


// 处理编辑框的滚动通知
			else if (HIWORD(wParam) == EN_VSCROLL) {
				HWND editHwnd = (HWND)lParam;
				if (editHwnd == g_renameSourcesEdit || editHwnd == g_renameTargetsEdit) {
					//g_editSync.SynchronizeScroll(editHwnd);
				}
			}
